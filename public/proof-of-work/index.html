<!DOCTYPE html>
<html lang="en-US">
<head>
  <script src="https://syst3mz.github.io/theme.min.js" integrity="sha384-IpIaa84kOKgkF5EJ0fD/kBe2wtIIsIB60ANGmuJxeA0dz5bSRfwBwp2/QybtQpU2"></script>
  <link rel="stylesheet" href="https://syst3mz.github.io/abridge-switcher.css?h=209a1f16dd0c0675205867ed9acd4c061e165edc5cd4cfee86e5f6e8b3dbe9b3" />
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <link rel="preload" as="style" class="preStyle" href="https://syst3mz.github.io/katex.min.css" integrity="sha384-wd9jGzPpRmShp/NVcK7d6EhBheD8L4YBGszWIPVmSdb+dzqIrYPTcsPQuFEPl4Th" />
  <script defer src="https://syst3mz.github.io/abridge-bundle.min.js?h=f0e7958f46d06221e99d6d7f24150858523908ca5ca41865ddfba64bc9466f6a" integrity="sha384-nUzn1rJBMPtXHTJcP76DAl7M3pn9hUVGWBMq6iYleX0NZ/ec+/xQ6nl8iXbBLfCs"></script>
  <script defer src="https://syst3mz.github.io/katexbundle.min.js?h=a550ba0540c37778ffcb0ddcf7968ee7c5c991905ad4db41b445e3dc4187ac40" integrity="sha384-ddSpLWE2IN4NTX956m9zVX0cUonZmEeunMpVZPgEcwmGficsSB8WtHlbuWkGPf8d"></script>
  <meta name="base" content="https://syst3mz.github.io" />
  <link rel="alternate" type="application/atom+xml" title="Atom/RSS Feed" href="https://syst3mz.github.io/atom.xml" />
  <meta name="robots" content="index, follow" />
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <title>Proof of work | Ethan's Portfolio</title>
  <meta name="author" content="Ethan Ansburg" />
  <meta name="copyright" content="Ethan&#x27;s Portfolio" />
  <meta name="description" content="A website to show off my projects and aspirations." />
  <link rel="canonical" href="https://syst3mz.github.io/proof-of-work/" />
  <meta name="keywords" content="Abridge, Abridge.css, Zola, Theme, Zola Theme, getzola, Semantic Html, Fast, lightweight" />
  <meta property="og:url" content="https://syst3mz.github.io/proof-of-work/" />
  <meta name="twitter:url" content="https://syst3mz.github.io/proof-of-work/" />
  <meta property="og:description" content="A website to show off my projects and aspirations." />
  <meta name="twitter:description" content="A website to show off my projects and aspirations." />
  <meta property="og:title" content="Proof of work | Ethan&#x27;s Portfolio" />
  <meta name="twitter:title" content="Proof of work | Ethan&#x27;s Portfolio" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://syst3mz.github.io/banner.png" />
  <meta property="og:image" content="https://syst3mz.github.io/banner.png" />
  <meta property="og:site_name" content="Ethan&#x27;s Portfolio" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="website" />
  <meta property="og:updated_time" content="2023-04-09" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <noscript><link rel="stylesheet" href="https://syst3mz.github.io/nojs.css" /></noscript>
</head>
<body>
  <header>
    <nav>
      <div><h1><a href="https://syst3mz.github.io/">Ethan Ansburg</a></h1></div>
      <div>
        <ul><li> <h2><a href="https://syst3mz.github.io/projects/">Projects</a></h2> </li><li> <h2><a href="https://syst3mz.github.io/resume">Resume</a></h2> </li><li class="js"><i type="reset" id="mode" class="svgs adjust"></i></li></ul>
      </div>
      <div>
        <form autocomplete=off class="js" name="goSearch" id="searchbox">
          <div class="searchd">
            <input id="searchinput" type="text" placeholder="Search" title="Search" />
            <button type="submit" title="Search"><i class="svgs search"></i></button>
          </div>
          <div><div id="suggestions"></div></div>
        </form>
      </div>
    </nav>
  </header>
  <main>
    <article>
        <h1><a href="https://syst3mz.github.io/proof-of-work/">Proof of work</a></h1>
        <span class="s95"> Ethan Ansburg<span class="hpad"> </span> April 09, 2023<span class="hpad"> </span></span>

    <p>Showing off something cool!</p>
<h1 id="kepler-s-equation">Kepler's Equation</h1>
<p>Johannes Kepler was a 16th century astronomer (among many other things) from Germany. He is well known for establishing the way planets moved around the sun with his laws of planetary motion. As it turns out, these laws can be applied to many non-planet celestial objects, and can accurately predict the position of objects in orbits. </p>
<p>This simulation was programmed using Kepler's laws. Click anywhere in the black box bellow to interact with the simulation. If you can't see it, grab a .exe version <a rel="noopener" target="_blank" href="https://github.com/Syst3mz/kepler_sim/releases/tag/1.0.0">here</a>.</p>
<p><canvas id="glcanvas" tabindex='1' width="800" height="600"></canvas></p>
<script src="https://not-fl3.github.io/miniquad-samples/mq_js_bundle.js"></script>
<script>load("./../kepler_sim.wasm");</script>
<p>Use J to reduce the timescale, K to reset it to 10, L to increase the timescale.</p>
<p>Holding shift will multiply the change by 10, holding z will multiply the change by 100, holding both will multiply the change by 1000.</p>
<p>You can note that as the red &quot;distance&quot; numbers increase, the speed of the planet decreases. This shows that my simulation is abiding by Kepler's laws which would predict that objects further from the body they are orbiting must be going slower.</p>
<h1 id="more-information-about-orbits">More information About Orbits</h1>
<p>A great video about orbits, which helped serve as the foundation of this project can be found <a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=t89De819YMA">here</a> It goes in to significant depth about the techniques used to simulate orbits, as well as being very well animated and voiced. They take this project much further than I have.</p>
<p>Another great video by Sebastian Lague can be found <a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=7axImc1sxa0">here</a>.</p>
<p>And I would of course be remiss not to include the <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Kepler%27s_laws_of_planetary_motion">Wikipedia</a> page for Kepler's laws. </p>
<h1 id="technical-information-about-the-project">Technical Information About the Project</h1>
<p>I wrote this simulation in the Rust programming language because Rust is fast and portable. This simulation is not the most efficient simulation of planetary orbits, and the rendering of orbital paths is particularly in-efficient. The next task to improve this project would be to speed up the line drawing significantly. For graphics, I am using the <a rel="noopener" target="_blank" href="https://macroquad.rs/">Macroquad</a> crate, which was perfect for this project because of its ability to compile to <a rel="noopener" target="_blank" href="https://webassembly.org/">WASM</a> allowing easy deployment to modern web browsers.</p>
<h2 id="how-does-the-simulation-work">How does the simulation work?</h2>
<p>The simulation is really a fancy equation solver. The equation I try to solve is $M = E - esin(E)$ Where $M$ is the mean anomaly, $E$ is the eccentric anomaly, and $e$ is the eccentricity. For a fantastic explanation of what these values mean, see <a rel="noopener" target="_blank" href="https://youtu.be/t89De819YMA?t=386">here</a>. Once $M$ is found, I can use a little trigonometry ($\sin$ and $\cos$, my old enemies) and a planets semi major and minor axises to find that planet's position in space. From there its just a bit of rendering math that Macroquad spared me from to get planets going in a ellipse.</p>
<p>The major issue of this approach is finding E. Kepler himself doubted the existence of closed form solution to his equation, and to this day no such solution has been found. Right now, the best we can do is use a variety of root finding algorithms to approach a true answer, but we can't ever guarantee that we have found a &quot;perfect&quot; solution. I chose to use Newton's method to solve this equation because I knew it from Calculus and it is relatively simple tio implement. </p>
<p>Here is the full equation solver at the heart of the simulator:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-storage z-type z-rust">const</span> <span class="z-constant z-other z-rust">EPSILON</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">f64</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-constant z-numeric z-float z-rust">0.</span><span class="z-constant z-numeric z-float z-rust">000001</span><span class="z-punctuation z-terminator z-rust">;</span>
<span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">newtons_method</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>F, G<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">x0</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">f64</span>, <span class="z-variable z-parameter z-rust">fx</span><span class="z-punctuation z-separator z-rust">:</span> F, <span class="z-variable z-parameter z-rust">dx</span><span class="z-punctuation z-separator z-rust">:</span> G</span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">f64</span>
    </span></span><span class="z-meta z-function z-rust"><span class="z-keyword z-other z-rust">where</span> F<span class="z-punctuation z-separator z-rust">:</span> Fn<span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-rust">f64</span><span class="z-punctuation z-section z-group z-end z-rust">)</span> -&gt; <span class="z-storage z-type z-rust">f64</span>, G<span class="z-punctuation z-separator z-rust">:</span> Fn<span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-rust">f64</span><span class="z-punctuation z-section z-group z-end z-rust">)</span> -&gt; <span class="z-storage z-type z-rust">f64</span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-storage z-type z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> root <span class="z-keyword z-operator z-assignment z-rust">=</span> x0<span class="z-punctuation z-terminator z-rust">;</span>

    <span class="z-keyword z-control z-rust">loop</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
        <span class="z-storage z-type z-rust">let</span> next_root <span class="z-keyword z-operator z-assignment z-rust">=</span> root <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-support z-function z-rust">fx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>root</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-support z-function z-rust">dx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>root</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
        <span class="z-storage z-type z-rust">let</span> delta <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-storage z-type z-rust">f64</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span>abs<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>next_root <span class="z-keyword z-operator z-arithmetic z-rust">-</span> root</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
        root <span class="z-keyword z-operator z-assignment z-rust">=</span> next_root<span class="z-punctuation z-terminator z-rust">;</span>

        <span class="z-keyword z-control z-rust">if</span> delta <span class="z-keyword z-operator z-comparison z-rust">&lt;=</span> <span class="z-constant z-other z-rust">EPSILON</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
            <span class="z-keyword z-control z-rust">break</span><span class="z-punctuation z-terminator z-rust">;</span>
        </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>

    root
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>Lets walk through it line by line:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-storage z-type z-rust">const</span> <span class="z-constant z-other z-rust">EPSILON</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">f64</span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-constant z-numeric z-float z-rust">0.</span><span class="z-constant z-numeric z-float z-rust">000001</span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>For reasons unknown to me, epsilon is chosen to mean: &quot;some very small value&quot;. I will not break mathematical tradition so epsilon is some very small value, in this case $\frac{1}{1,000,000}$. Due to how Newton's method converges on a solution, when the changes to the guess start to be very small, we can be highly confident we are near a root. Epsilon controls how small my program considers &quot;small enough&quot;.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">newtons_method</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>F, G<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">x0</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">f64</span>, <span class="z-variable z-parameter z-rust">fx</span><span class="z-punctuation z-separator z-rust">:</span> F, <span class="z-variable z-parameter z-rust">dx</span><span class="z-punctuation z-separator z-rust">:</span> G</span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">f64</span>
</span></span></span></code></pre>
<p>This is Rust for: &quot;Define a function called <code>newtons_method</code>. It accepts three arguments called <code>x0</code>, <code>fx</code>, <code>dx</code> returns a decimal number.&quot; The <code>&lt;F, G&gt;</code> tells Rust, that <code>newtons_method</code> accepts arguments of any type and should call those types <code>F</code> and <code>G</code>.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-keyword z-other z-rust">where</span> F<span class="z-punctuation z-separator z-rust">:</span> <span class="z-support z-type z-rust">Fn</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-rust">f64</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">f64</span></span><span class="z-punctuation z-separator z-rust">,</span> G<span class="z-punctuation z-separator z-rust">:</span> <span class="z-support z-type z-rust">Fn</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-storage z-type z-rust">f64</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">f64</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></code></pre>
<p>This restricts what data type can be put into <code>F</code> and <code>G</code> to be: &quot;Any function which takes a decimal number as input, returns a decimal number as output.&quot;</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-storage z-type z-rust">let</span> <span class="z-storage z-modifier z-rust">mut</span> root <span class="z-keyword z-operator z-assignment z-rust">=</span> x0<span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>Make a variable called <code>root</code>, assign <code>x0</code> to it. Rust does not let variables change by default, so the <code>mut</code> before <code>root</code> lets <code>root</code> change. Newton's method requires an initial guess (often called $x_0$) the better this initial guess is, the faster Newton's method will converge to a root of the function.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-keyword z-control z-rust">loop</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></code></pre>
<p>Do whatever comes after me forever.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-storage z-type z-rust">let</span> next_root <span class="z-keyword z-operator z-assignment z-rust">=</span> root <span class="z-keyword z-operator z-arithmetic z-rust">-</span> <span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span><span class="z-support z-function z-rust">fx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>root</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-arithmetic z-rust">/</span> <span class="z-support z-function z-rust">dx</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>root</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>this is the Newton's method &quot;part&quot; of the algorithm. Newtons method is defined as $$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$. In english, the next guess is equal to the current guess minus f of the current guess over the derivative of f of the current guess.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-storage z-type z-rust">let</span> delta <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-storage z-type z-rust">f64</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span>abs<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>next_root <span class="z-keyword z-operator z-arithmetic z-rust">-</span> root</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>Compute how far the new guess is from the previous guess. The abs is there because we only care about the distance on the number line.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust">root <span class="z-keyword z-operator z-assignment z-rust">=</span> next_root<span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>set <code>root</code> to the next guess (<code>next_root</code>).</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-keyword z-control z-rust">if</span> delta <span class="z-keyword z-operator z-comparison z-rust">&lt;=</span> <span class="z-constant z-other z-rust">EPSILON</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
    <span class="z-keyword z-control z-rust">break</span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre>
<p>I grouped these three lines, because they all act as one &quot;thing&quot;. If the change (<code>delta</code>) is less than or equal to epsilon, stop the infinite loop.</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust">root
</span></code></pre>
<p>spit out what ever root was calculated.</p>
<p>In brief, this function can compute roots of any differentiable equation...eventually. Since Kepler's Equation is (in fact) an equation, Newton's method works for it!
Once we have this, solving for $E$ is as simple as: </p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">solve_keplers</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">mean_anomaly</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">f64</span>, <span class="z-variable z-parameter z-rust">eccentricity</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">f64</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">f64</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
        <span class="z-storage z-type z-rust">let</span> eccentric_anomaly <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-keyword z-control z-rust">if</span> eccentricity <span class="z-keyword z-operator z-comparison z-rust">&gt;</span> <span class="z-constant z-numeric z-float z-rust">0.</span><span class="z-constant z-numeric z-float z-rust">8</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span> <span class="z-storage z-type z-rust">f64</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-constant z-other z-rust">PI</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span> <span class="z-keyword z-control z-rust">else</span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>mean_anomaly</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
        <span class="z-support z-function z-rust">newtons_method</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
            eccentric_anomaly<span class="z-punctuation z-separator z-rust">,</span>
            <span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">|</span></span></span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-variable z-parameter z-rust">eccentric_anomaly</span><span class="z-punctuation z-section z-parameters z-end z-rust">|</span></span> </span><span class="z-meta z-function z-closure z-rust"><span class="z-storage z-type z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span>keplers_equation<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>mean_anomaly<span class="z-punctuation z-separator z-rust">,</span> eccentric_anomaly<span class="z-punctuation z-separator z-rust">,</span> eccentricity</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-separator z-rust">,</span>
            <span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">|</span></span></span><span class="z-meta z-function z-closure z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-variable z-parameter z-rust">eccentric_anomaly</span><span class="z-punctuation z-section z-parameters z-end z-rust">|</span></span> </span><span class="z-meta z-function z-closure z-rust"><span class="z-storage z-type z-rust">Self</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span>keplers_equation_derivation<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>eccentric_anomaly<span class="z-punctuation z-separator z-rust">,</span> eccentricity</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span></span>
        </span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
    </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>You might note at the top of the function, I guess that eccentric anomaly is either $\pi$ or what ever the mean anomaly. This is the seed value for Newton's method ($x_0$). These specific starting values are recommended by Anderson, and have worked well for me.</p>

<p><b><a href="#">Back to top</a></b></p>
    </article>
  </main>
  <footer>
    <hr />
    <div class="c">
      <nav>
        <ul><li class="js"><a class="m-protected" href="#ZXRoYW4uYW5zYnVyZytqb2JzQHByb3Rvbm1haWwuY29t" target="_blank" title="Mail"><i type="Button" class="svg mail" title="Mail"></i></a></li><li><a href="https://github.com/Syst3mz/" target="_blank" title="Github"><i type="Button" class="svg github" title="Github"></i></a></li></ul>
      </nav>
      <p class="s90">Copyright &copy; 2023 Ethan&#x27;s Portfolio</p>
      <nav>
        <ul><li class="s90"> <a href="https://syst3mz.github.io/"> About </a> </li><li class="s90"> <a href="https://syst3mz.github.io/contact/"> Contact </a> </li><li class="s90"> <a href="https://syst3mz.github.io/privacy/"> Privacy </a> </li><li class="s90"> <a href="https://syst3mz.github.io/sitemap.xml" target="_blank"> Sitemap </a> </li></ul>
      </nav>
      <p class="s90">Powered by <a href="https://www.getzola.org/" target="_blank">Zola</a> and <a href="https://github.com/jieiku/abridge/" target="_blank">Abridge</a></p>
    </div>
  </footer>
<span class="topout">
<span class="topleft"> </span><a href="#" class="top" title="Back to Top"><i class="svgs svgh angu"></i></a>
</span>
</body>
</html>